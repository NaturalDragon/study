<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    //1.工厂模式(虽然可以解决多个类似对象的问题，但没有解决对象标识问题，即新创建的对象是什么类型)
    /*
    function createPerson(name,age,job) {
        let o=new Object()
        o.name=name;
        o.age=age;
        o.job=job;
        o.sayHi=function(){
            console.log(this.name)
        }
        return o
    }
    let person1=createPerson('lizn',18,'engine');
    let person2=createPerson('cy',18,'se')
    */

    /*
    //2.构造函数模式
    // (没有显示创建对象，属性和方法直接赋值给了this);缺点：其定义的方法会在每个实例上都创建一遍
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function () {
            console.log(this.name);
        };

    }
    //作为构造函数调用
    let person1 = new Person('lizn', 18, 'enginee')
    let person2 = new Person//('cy', 18, 'xs')

    //作为函数调用---》添加到window对象
    Person('lyf', 1.5, 'naiwa')
    window.sayName()

    //在另外一个对象的作用域中调用
    let o = new Object();
    Person.call(o, 'cyf', 1.5, 'naiwa')
    o.sayName()
*/

    /*
        // 2.1构造函数改造(把函数定义移动到外部，问题是搞乱全局作用域)
        function sayName () {
                console.log(this.name);
            };
        function Person(name, age, job) {
            this.name = name;
            this.age = age;
            this.job = job;
            this.sayName = sayName
        }
    */
    /*
    // 3.原型模式

    function Person() {
    }
    Person.prototype.name = 'lizn';
    Person.prototype.age = 18;
    Person.prototype.sayHi = function () {
        console.log(this.name)
    }

    let person1 = new Person();
    person1.sayHi(); // "Nicholas"
    let person2 = new Person();
    person2.sayHi(); // "Nicholas"

    console.log(person1.sayHi === person2.sayHi)

    function Mother(){
        this.hair='long'
    }
    //重写一个对象的原型继承关系
    Object.setPrototypeOf(person1,Mother)

   let person3= Object.create(Mother.prototype)
   */

    /*

     //    3.1、原型模式优化
     //     优点：封装性好了一些
     // 缺点：重写了原型，丢失了constructor属性
     function Person() {
     }
     Person.prototype = {
         name: 'lizn',
         age: 18,
         sayHi: function () {
             console.log(this.name)
         }
     }

     let person1 = new Person();
     person1.sayHi();
     let person2 = new Person();
     person2.sayHi();
     */

    /*
   // 3.2原型模式优化
   // 优点：实例可以通过constructor属性找到所属构造函数
   // 缺点：原型模式有的缺点还是有
   function Person() {
   }
   Person.prototype = {
       constuctor: Person,
       name: 'lizn',
       age: 18,
       sayHi: function () {
           console.log(this.name)
       }
   }

   let person1 = new Person();
   person1.sayHi();
   let person2 = new Person();
   person2.sayHi();
   */

    //    4.组合模式
    function Person(name, age) {
        this.name = name;
        this.age = age
    }
    Person.prototype = {
        constuctor: Person,
        sayHi: function () {
            console.log(this.name, this.age)
        }
    }
    let person1 = new Person('lizn', 18);
    person1.sayHi();
    let person2 = new Person('cy', 18);
    person2.sayHi();
</script>